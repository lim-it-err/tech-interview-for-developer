## ARM 프로세서

<br>

*프로세서란?*

> 메모리에 저장된 명령어들을 실행하는 유한 상태 오토마톤

<br>

##### ARM : Advanced RISC Machine

즉, `진보된 RISC 기기`의 약자로 ARM의 핵심은 RISC이다.

RISC : Reduced Instruction Set Computing (감소된 명령 집합 컴퓨팅)

`단순한 명령 집합을 가진 프로세서`가 `복잡한 명령 집합을 가진 프로세서`보다 훨씬 더 효율적이지 않을까?로 탄생함

<br>

<br>

#### ARM 구조

---

<img src="https://t1.daumcdn.net/cfile/tistory/25788C3550CAF8731A" width="500">

<br>

ARM은 칩의 기본 설계 구조만 만들고, 실제 기능 추가와 최적화 부분은 개별 반도체 제조사의 영역으로 맡긴다. 따라서 물리적 설계는 같아도, 명령 집합이 모두 다르기 때문에 서로 다른 칩이 되기도 하는 것이 ARM.

소비자에게는 칩이 논리적 구조인 명령 집합으로 구성되면서, 이런 특성 때문에 물리적 설계 베이스는 같지만 용도에 따라 다양한 제품군을 만날 수 있는 특징이 있다.

아무래도 아키텍처는 논리적인 명령 집합을 물리적으로 표현한 것이므로, 명령어가 많고 복잡해질수록 실제 물리적인 칩 구조도 크고 복잡해진다.

하지만, ARM은 RISC 설계 기반으로 '단순한 명령집합을 가진 프로세서가 복잡한 것보다 효율적'임을 기반하기 때문에 명령 집합과 구조 자체가 단순하다. 따라서 ARM 기반 프로세서가 더 작고, 효율적이며 상대적으로 느린 것이다.

<br>

단순한 명령 집합은, 적은 수의 트랜지스터만 필요하므로 간결한 설계와 더 작은 크기를 가능케 한다. 반도체 기본 부품인 트랜지스터는 전원을 소비해 다이의 크기를 증가시키기 때문에 스마트폰이나 태블릿PC를 위한 프로세서에는 가능한 적은 트랜지스터를 가진 것이 이상적이다.

따라서, 명령 집합의 수가 적기 때문에 트랜지스터 수가 적고 이를 통해 크기가 작고 전원 소모가 낮은 ARM CPU가 스마트폰, 태블릿PC와 같은 모바일 기기에 많이 사용되고 있다.

<br>

<br>

#### ARM의 장점은?

---

<img src="https://t1.daumcdn.net/cfile/tistory/1970603350CD96BC35" width=200>

<br>

소비자에 있어 ARM은 '생태계'의 하나라고 생각할 수 있다. ARM을 위해 개발된 프로그램은 오직 ARM 프로세서가 탑재된 기기에서만 실행할 수 있다. (즉, x86 CPU 프로세서 기반 프로그램에서는 ARM 기반 기기에서 실행할 수 없음)

따라서 ARM에서 실행되던 프로그램을 x86 프로세서에서 실행되도록 하려면 (혹은 그 반대로) 프로그램에 수정이 가해져야만 한다.

 <br>

하지만, 하나의 ARM 기기에 동작하는 OS는 다른 ARM 기반 기기에서도 잘 동작한다. 이러한 장점 덕분에 수많은 버전의 안드로이드가 탄생하고 있으며 또한 HP나 블랙베리의 태블릿에도 안드로이드가 탑재될 수 있는 가능성이 생기게 된 것이다.

(하지만 애플사는 iOS 소스코드를 공개하지 않고 있기 때문에 애플 기기는 불가능하다)

ARM을 만드는 기업들은 통해 전력 소모를 줄이고 성능을 높이기 위해 설계를 개선하며 노력하고 있다.

<br>

<br>

<br>

### ARM (RISC 기반)
RISC (Reduced Instruction Set Computer): 간단하고 속도가 빠른 명령어를 사용합니다. 이는 명령어의 실행 시간을 줄이고, CPU의 효율성을 높입니다.
- 저전력 소모: ARM 아키텍처는 모바일 장치와 임베디드 시스템에 적합하도록 설계되었습니다. 이는 저전력 설계에 중점을 둡니다.
- 단순한 하드웨어 설계: RISC 아키텍처는 상대적으로 단순한 CPU 설계를 가능하게 합니다. 이는 제조 비용을 낮추고, 소형 장치에 적합합니다.
- 고정된 명령어 길이: 명령어가 고정된 길이를 가지므로, 파이프라인 처리가 용이합니다.

### Intel (CISC 기반)
CISC (Complex Instruction Set Computer): 복잡하고 강력한 명령어를 사용합니다. 이는 단일 명령어로 여러 작업을 수행할 수 있게 합니다.
- 높은 성능: CISC 아키텍처는 강력한 컴퓨팅 요구를 충족시키도록 설계되었습니다. 이는 데스크톱, 서버, 고성능 컴퓨팅에 적합합니다.
- 복잡한 하드웨어 및 소프트웨어 최적화: CISC 아키텍처는 다양한 명령어를 처리할 수 있는 복잡한 CPU 설계를 필요로 합니다. 이는 고성능을 달성하기 위한 소프트웨어 최적화도 필요로 합니다.
- 가변적인 명령어 길이: 명령어의 길이가 가변적이므로, 복잡한 작업을 더 효율적으로 처리할 수 있습니다.



## ARM 인스트럭션 세트 예시 (RISC)
ARM 인스트럭션 세트는 간결하고 효율적인 명령어를 제공합니다. 각 명령어는 단순하고 예측 가능한 연산을 수행하도록 설계되었습니다. 예를 들어, ARM 아키텍처에서는 다음과 같은 명령어를 사용할 수 있습니다:

MOV R0, #5 : 상수 5를 레지스터 R0에 이동시킵니다.
ADD R1, R2, R3 : R2와 R3의 값을 더하고 결과를 R1에 저장합니다.
STR R0, [R1] : R0의 값을 R1이 가리키는 메모리 주소에 저장합니다.
이러한 명령어들은 간단하고 명료하여, 프로그래머나 컴파일러가 예측하기 쉬운 행동을 하고, 파이프라이닝과 같은 기술을 통해 빠르게 실행될 수 있습니다.

Intel 인스트럭션 세트 예시 (CISC)
Intel의 인스트럭션 세트는 CISC 아키텍처의 복잡성을 반영하여, 보다 복잡한 연산을 단일 명령어로 수행할 수 있습니다. 예를 들어, Intel x86 아키텍처에서는 다음과 같은 명령어를 사용할 수 있습니다:

MOV AX, 5 : 상수 5를 레지스터 AX에 이동시킵니다. (ARM 예시와 유사하지만, 인스트럭션 세트의 구성이 다름)
ADD AX, BX : AX와 BX의 값을 더하고 결과를 AX에 저장합니다.
LEA BX, [SI + DI + 8] : 복잡한 메모리 주소 계산을 한 명령어로 수행하고, 결과를 BX에 저장합니다.
CISC 아키텍처에서는 단일 명령어가 여러 단계의 연산을 수행할 수 있으며, 이는 프로그램의 메모리 사용량을 줄이고, 때로는 실행 속도를 향상시킬 수 있습니다. 그러나 이러한 복잡성은 명령어의 디코드와 실행이 더 복잡하고, 때로는 더 많은 사이클을 필요로 할 수 있습니다.

결론
RISC 아키텍처인 ARM은 각 명령어가 단순하고 효율적인 연산을 수행하도록 설계되어 있어, 저전력 소모와 빠른 실행 속도를 강점으로 합니다. 반면, CISC 아키텍처인 Intel은 복잡한 연산을 단일 명령어로 수행할 수 있어, 프로그램의 메모리 사용량을 줄이고 특정 상황에서 성능을 최적화할 수 있습니다. 이러한 차이는 각 아키텍처를 선택할 때 고려해야 할 중요한 요소입니다.

* 명령어 길이가 고정되어 있다는 것은, 컴퓨터 아키텍처에서 모든 기계어 명령어가 동일한 비트 수를 가진다는 의미입니다

## 고정 길이에 따른 최적화

ARM 아키텍처가 각 명령어를 고정된 길이로 처리하는 방식과 이것이 파이프라인의 각 단계에서 처리 시간을 어떻게 일정하게 유지하는지에 대해 설명하겠습니다. 이 과정을 이해하기 위해, 우선 CPU에서 명령어 파이프라이닝이 작동하는 방식과 명령어의 길이가 이 과정에 미치는 영향을 기본적으로 알아야 합니다.

파이프라이닝 기본
파이프라이닝은 CPU가 명령어를 처리하는 과정을 여러 동시 진행 가능한 단계로 나누어, 한 번에 여러 명령어를 처리할 수 있게 하는 기술입니다. 전통적으로 5단계로 나누어지는 이 과정은 인출(Fetch), 디코딩(Decode), 실행(Execute), 메모리 접근(Memory Access), 쓰기 백(Write Back)을 포함합니다.

고정된 명령어 길이의 중요성
ARM 같은 RISC 아키텍처에서 명령어 길이가 고정되어 있다는 것은, 모든 명령어가 같은 비트 수를 가진다는 의미입니다. 이는 CPU가 명령어를 인출할 때 필요한 비트 수를 미리 알고 있으며, 각 명령어를 인출, 디코딩하는 데 필요한 시간이 항상 동일하다는 것을 의미합니다.

단계별 처리 시간의 일정성
파이프라인의 각 단계는 다른 명령어의 다른 단계와 병렬로 수행될 수 있습니다. 예를 들어, 첫 번째 명령어가 실행 단계에 있을 때, 다음 명령어는 동시에 디코딩 단계에 있을 수 있습니다. 명령어 길이가 고정되어 있으면, CPU는 각 단계를 일정한 시간 내에 완료할 수 있도록 설계될 수 있습니다. 이는 각 파이프라인 단계의 처리 시간을 최적화하고 균일하게 유지하기 위해 설계된 결과입니다.

설계상의 고려사항
명령어 파이프라이닝에서 단계별로 시간을 맞추는 것은 복잡한 과제입니다. 고정된 명령어 길이를 가진 아키텍처는 이 과제를 단순화합니다. 모든 명령어가 같은 길이를 가지므로, 각 단계(특히 인출과 디코딩)에서 처리해야 할 데이터의 양이 일정합니다. 이로 인해 각 단계의 처리 시간을 더 예측 가능하게 만들고, 전체적으로 파이프라인의 효율을 극대화할 수 있습니다.

하지만 실제로는 각 단계별 처리 시간에 완벽한 일정성을 달성하는 것이 불가능할 수 있습니다. 예를 들어, 메모리 접근 단계는 메모리의 상태나 캐시 미스 등에 의해 영향을 받을 수 있습니다. 따라서 설계자들은 파이프라인의 각 단계가 가능한 한 균일하게 동작하도록 최적화하지만, 모든 상황에서 완벽한 균일성을 보장하기는


##### [참고 자료]

- [링크](https://sergeswin.com/611)

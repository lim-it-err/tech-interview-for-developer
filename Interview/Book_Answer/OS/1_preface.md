# 프로세스
## Review
1. 프로세스는 현대의 컴퓨팅 시스템에서의 작업의 단위이다.
2. 프로세스의 현재 상태는 프로그램 카운터 값과 프로세서 레지스터로 나타낸다. 
- 프로그램 카운터 : 현재 실행되는 명령어의 위치와, 다음에 실행될 명령어의 주소
- 프로세서 레지스터 : 방금 읽어 들어 들인 명령어를 저장하는 레지스터 
- 이러한 값들은 Context Switch 때, PCB에 저장된다. 
- PCB는 커널 영역의 메모리에 저장된다. 이는 사용자 메모리에 저장되는 Text, Data, Heap, Stack과 다른 영역이다.
- 커널 영역에는 프로세스의 현재 상태(대기, 실행, 종료 등), 프로그램 카운터, CPU 레지스터 값, 메모리 관리 정보(페이지 테이블 등) 등을 저장한다.


## 내가 만든 질문
1. 프로세스는 크게 유저 모드와 커널 모드에서 메모리를 점유하고 있습니다. 유저 모드와 커널 모드에서 프로세스가 차지하는 메모리의 크기가 커지는 경우에 대해 각기 서술하세요.
   - 유저 모드
     - 힙 영역에서 동적 할당을 통해 메모리를 키운다. 
   - 커널 모드 
     - 프로세스가 SSD에서 큰 파일을 요청할 경우, DMA를 활용하여 데이터를 직접 수신한다. 이 때, 해당 데이터는 프로세스에서 관리하나, 제한된 메모리로 인해 Page Table에서 Swap이 필요하게 될 경우 커널 영역에서 Page Table을 참조한다. 
     - 프로세스의 스레드 수가 급증하게 되면, 각 스레드에 대한 메타데이터를 관리하기 위한 커널 메모리 사용량이 증가한다. 
       - 가령 PID, PC, Register, Stack Pointer 등 프로세스의 메타데이터와 유사하다.
       
2. 파이썬에서 `open(file)`이 수행 될 때, 컴퓨터 내부에서는 어떤 일이 일어날까?
   - 시스템 호출을 초기화하며, 해당 프로세스는 user mode 에서 kernel mode로 전환된다. (Trap mode bit를 1로 변환한다.)
   - 파일 트리 구조에서, 해당 파일의 위치를 통한 파일을 찾는다. 디스크와 HDD, SSD에 따라 파일을 찾는 방법이 다르다.
   - 파일 디스크립터를 생성한다. 
     - 소켓을 대표하는 정수값으로, 0~2는 할당되어 있다. Mac은 주로 255까지 사용된다. 
     - 파일 디스크립터 수가 255를 넘어가게 될 경우 에러 리턴
     - 파일 디스크립터의 범위는 프로세스 내이다. (타 프로세스에서도 동일한 숫자의 디스크립터를 보유할 수 있다.)
   - 파일 디스크립터는 FD 플래그와 파일 테이블로의 포인터를 가지고 있다. 파일 테이블은 Inode(Unix의 데이터 저장 자료구조)의 포인터를 가지고 있다. 
   - 파일 디스크립터를 회수한다.
   
3. `sudo` 권한을 가지면, kernel 모드로의 진입이 가질 수 있으며, 이 역 또한 성립한다. (O/X)
4. `DMA`는 커널 모드의 프로세스에서만 제어 가능하다 (O)
5. 해당 코드가 구동될 때, 프로세스의 메모리 영역에 대하여 설명하세요.
```
#include <cstdlib>

void func(int cnt = 5) {
    int x = 10; // 스택에 저장되는 로컬 변수
    void* y = malloc(500 * 1024 * 1024); // 500MB 할당
    if (cnt - 1 > 0) {
        func(cnt - 1);
    }
    free(y); // 동적으로 할당된 메모리 해제
}

int main() {
    func();
    return 0;
}

```
1. 프로세스가 생성되며, 유저 모드에서는 Text, Data, Heap, Stack이 생성된다.
2. 재귀 함수 정보 등은 스택에, malloc 에 저장된 y 값은 Heap에 저장된다.
3. 동적 메모리 할당(malloc): malloc 함수를 호출할 때 요청한 메모리 양은 힙(Heap) 영역에서 할당됩니다. 예를 들어, 프로그램이 500MB를 요청하면, 운영 체제는 프로세스의 힙 영역에 500MB를 할당하려고 시도합니다.
실제 메모리 사용: 프로세스가 malloc로 500MB를 요청한다고 해서, 실제 물리적 메모리(RAM)에서 즉시 500MB가 소모되는 것은 아닙니다. 현대 운영 체제는 가상 메모리 시스템을 사용하여, 필요에 따라 실제 메모리 페이지를 할당하고, 사용되지 않는 페이지는 스왑 영역(swap space)으로 이동시킵니다.
가상 메모리: 가상 메모리 시스템을 통해, 프로세스는 자신이 실제보다 더 많은 메모리를 가진 것처럼 동작할 수 있습니다. 이는 프로세스에 할당된 "가상" 주소 공간을 통해 가능한데, 이 가상 주소 공간은 물리적 메모리와 스왑 공간을 합친 것보다 클 수 있습니다.
